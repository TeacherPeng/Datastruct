1
00:00:00,000 --> 00:00:07,359
在讨论哈夫曼算法的实现之前，我们先回顾一下哈夫曼算法。

2
00:00:07,359 --> 00:00:13,349
哈夫曼算法的基本过程是先将每一个叶结点看作一棵独立的二叉树

3
00:00:13,349 --> 00:00:18,375
叶结点就是根结点，叶结点的权值就是根结点的权值。

4
00:00:18,375 --> 00:00:22,894
这样，在初始的时候，我们就有N棵独立的二叉树

5
00:00:22,894 --> 00:00:33,778
然后进行N-1次合并，每次合并都是挑选两个根结点权值最小的二叉树进行合并

6
00:00:33,778 --> 00:00:36,439
合并的方法是增加一个父结点

7
00:00:36,439 --> 00:00:44,547
将挑选出的根结点权值最小的两棵二叉树作为新增父结点的左子树和右子树

8
00:00:44,547 --> 00:00:51,897
并将被合并的两棵二叉树的根结点的权值之和作为合并后的二叉树的根结点的权值

9
00:00:51,897 --> 00:00:58,623
每合并一次后，会有两棵独立二叉树被合并成一棵二叉树

10
00:00:58,623 --> 00:01:02,611
所以独立二叉树的数量会减少一棵

11
00:01:02,611 --> 00:01:08,860
那么经过N-1趟合并后，加入了N-1个父结点

12
00:01:08,860 --> 00:01:13,978
原来的N个叶结点就被合并成一棵二叉树了

13
00:01:13,978 --> 00:01:17,805
这棵二叉树就是我们要求的哈夫曼树

14
00:01:17,805 --> 00:01:21,617
这个算法就是所谓哈夫曼算法

15
00:01:21,617 --> 00:01:28,261
要实现哈夫曼算法，我们首先讨论一下采用什么样的物理结构

16
00:01:28,261 --> 00:01:31,808
根据哈夫曼树的性质，我们可以知道

17
00:01:31,808 --> 00:01:39,909
由N个叶结点构成的哈夫曼树上，一定有N-1个度为2的非叶结点

18
00:01:39,909 --> 00:01:48,504
整棵哈夫曼树一共有2N-1个结点

19
00:01:48,504 --> 00:01:55,200
而构造哈夫曼树的过程，就是逐一加入非叶结点的过程

20
00:01:55,200 --> 00:01:59,434
最后一个加入的就是哈夫曼树的根结点

21
00:01:59,434 --> 00:02:07,391
既然总结点数是已知的，而构造过程又是一个结点一个结点追加的

22
00:02:07,391 --> 00:02:12,843
因此，可以考虑采用静态链表作为哈夫曼树的存储结构

23
00:02:12,843 --> 00:02:17,771
把已知的叶结点存在静态链表的前部

24
00:02:17,771 --> 00:02:21,145
再在后面逐一加入新增的非叶结点

25
00:02:21,145 --> 00:02:25,706
这里我们选用了静态三叉链表作为存储结构

26
00:02:25,706 --> 00:02:30,590
好，我们先来看一下物理结构的定义

27
00:02:30,590 --> 00:02:37,372
每个结点中的信息部分我们暂时用一个字符作为代表

28
00:02:37,372 --> 00:02:46,469
这个部分在哈夫曼算法中并不会被用到

29
00:02:46,469 --> 00:02:58,468
然后每个结点里需要有权值部分和链部分，静态链表里是用下标作为链

30
00:02:58,468 --> 00:03:07,677
三叉链结构中每个结点里有三条链，分别指向父结点、左子结点和右子结点

31
00:03:07,677 --> 00:03:15,001
那么整棵哈夫曼树就是由哈夫曼结点构成的一个静态链表

32
00:03:15,001 --> 00:03:24,958
在这里我们没有像一般顺序线性表那样存储表长，而是存储了叶结点的个数

33
00:03:24,958 --> 00:03:32,763
而表的长度是2倍的叶结点个数减1

34
00:03:32,763 --> 00:03:40,196
注意，并不是必须这样做，只是这里我们觉得存储叶结点的个数使用起来会更方便

35
00:03:40,196 --> 00:03:46,466
定义完存储结构之后，我们就来看具体的算法实现了。

36
00:03:46,466 --> 00:03:52,672
算法过程的输入是叶结点的个数和叶结点的权值

37
00:03:52,672 --> 00:04:03,527
输出是构造出来的静态三叉链结构的哈夫曼树。

38
00:04:03,527 --> 00:04:11,714
首先我们把要构造的哈夫曼树的存储空间初始化好

39
00:04:11,714 --> 00:04:23,090
根据叶结点个数算出静态三叉链表的长度，并分配好存储空间

40
00:04:23,090 --> 00:04:25,245
填入叶结点个数，然后把叶结点填到静态三叉链表的前半部分

41
00:04:25,245 --> 00:04:34,344
这里的信息部分只是一个示意，可以忽略

42
00:04:34,344 --> 00:04:40,558
初始化时，每个叶结点是一个独立的二叉树

43
00:04:40,558 --> 00:04:52,154
我们约定用-1表示空链的话，那么初始时每个叶结点的父链和子链就都是-1。

44
00:04:52,154 --> 00:04:58,377
接下来应该就要进入N-1次合并过程了

45
00:04:58,377 --> 00:05:06,475
不过在开始实现合并过程之前，我们先考虑一下合并过程中我们要做的工作

46
00:05:06,475 --> 00:05:13,835
合并过程中我们要先找出权值最小的两个根结点

47
00:05:13,835 --> 00:05:20,001
这个过程我们可以用在线性表中找最小值的方法来实现

48
00:05:20,001 --> 00:05:29,802
但这样就需要对已有的所有的结点进行遍历，每趟合并都需要做这样的遍历

49
00:05:29,802 --> 00:05:31,730
但只能这样做吗？

50
00:05:31,730 --> 00:05:34,177
分析一下不难发现

51
00:05:34,177 --> 00:05:43,532
新加入的非叶结点的权值是挑选出来的目前权值最小的两个根结点之和

52
00:05:43,532 --> 00:05:51,327
所以下次再挑选出来的两个根结点的权值就不会比这次的小

53
00:05:51,327 --> 00:05:57,240
因此非叶结点是按照权值递增的顺序生成的

54
00:05:57,240 --> 00:06:06,178
那么如果我们在合并之前，先把叶结点也按权值排一下序

55
00:06:06,178 --> 00:06:16,088
那么就可以把叶结点部分和已生成的非结点部分分别看作两个有序线性表

56
00:06:16,088 --> 00:06:25,878
而我们要找出权值最小的根结点，就只要在这两个表的表头找就可以了

57
00:06:25,878 --> 00:06:32,245
因此我们在合并之前，先对叶结点部分做一下排序

58
00:06:32,245 --> 00:06:56,927
并设置两个表头指针s和t，s指向叶结点部分的表头，t指向非叶结点部分的表头

59
00:06:56,927 --> 00:07:02,440
现在我们可以开始N-1次合并过程了

60
00:07:02,440 --> 00:07:10,008
每一趟合并过程中，我们要做三件事

61
00:07:10,008 --> 00:07:14,067
一是找出权值最小的根结点

62
00:07:14,067 --> 00:07:17,787
二是找出权值次小的根结点

63
00:07:17,787 --> 00:07:23,328
三是添加一个非叶结点，合并找出的两个根结点

64
00:07:23,328 --> 00:07:30,298
先看第一步，现在我们不需要对所有的已有结点进行遍历了

65
00:07:30,298 --> 00:07:40,092
只要比较叶结点部分和非叶结点部分的表头就可以确定最小的根结点了

66
00:07:40,092 --> 00:07:42,114
注意判定条件

67
00:07:42,114 --> 00:08:14,667
如果还有叶结点且没有非叶结点或当前非叶结点权值比当前叶结点权值大

68
00:08:14,667 --> 00:08:18,636
那么当前叶结点权值最小，令k1为s，并向后移动s

69
00:08:18,636 --> 00:08:30,199
否则当前非叶结点权值最小，令k1为t，并向后移动t。

70
00:08:30,199 --> 00:08:46,621
第二步和第一步相同，继续比较叶结点和非叶结点的表头

71
00:08:46,621 --> 00:08:58,191
确定出权值次小的根结点，并把下标记在k2中。

72
00:08:58,191 --> 00:08:59,394
找到权值最小的两个根结点k1和k2后

73
00:08:59,394 --> 00:09:18,001
第三步，追加一个父结点，新增结点的权值等于的找到的k1和k2结点的权值之和

74
00:09:18,001 --> 00:09:30,590
并将找到的k1和k2这两个根结点分别挂在新增父结点的左子和右子上

75
00:09:30,590 --> 00:09:41,600
至此，一趟合并完成，独立二叉树的数量少了一棵

76
00:09:41,600 --> 00:09:56,585
重复合并过程N-1趟，哈夫曼树构造完毕

77
00:09:56,585 --> 00:10:56,000
这时哈夫曼树的根结点就是静态三叉链表的最后一个结点
